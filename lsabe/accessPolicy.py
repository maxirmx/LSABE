# .... LSABE access policy ...

import sys
import random

#
#  Let A be an n × l matrix and p be the function that associates rows of A with the (security?) attributes.
#  The  access  policy  is  denoted  by (A,p). 

class accessPolicy:
    def __init__(self, n, l):
        self._n = n                     # The number of columns
        self._l = l                     # The number of rows


#  For testing simplicty I assume that A(i,0) = 1, A(i,j)=0 if j!=0 for any i
#  So no matrix is stored, I just generate a value as required 
#  Also I do not check that i is within valid range 0..l-1
    def A(self, i, j):
        if j==0:
            return 1
        return 0

# p - the function that associates rows of A with the (security?) attributes
# i - index of security attribute, we return it as a row of A
    def p(self,i):
        return "full access" #i

# A helper for lsabe.encrypt
# Choose a random s∈Zp and a random vector v∈Znp with s as its first entry.
    def randVector(self):
        v=[]
        for i in range(self._n):
            v.append(random.randrange(sys.maxsize)) 
        return v

# A helper for lsabe.encrypt
# For each i∈[l], we let λ(i) denote A(i)·v, where A(i) is row i of A 
# (and v - is a vector, generated by randVector)
    def lmbda(self, i, v):
        lm = 0
        for j in range (len(v)):
            lm += self.A(i,j)*v[j]
        return lm

# A helper for lsabe.transform
#  w - a set of constants {w(i)∈Zp} i∈N with Σ[w(i)*A(i)] = (1,0,...,0).
    def w(self, i):
        if i == 0:
            return 1
        return 0

