# .... LSABE access policy ...

import sys
import random

#
#  Let A be an n × l matrix and p be the function that associates rows of A with the (security?) attributes.
#  The access policy is denoted by (A,p). 

class accessPolicy:
    def __init__(self):
        self._n = 2                     # The number of columns
        self._l = 5                     # The number of rows (security attributes)

#   ... Security attributes ...
#   Security attribute is an abstraction representing the basic properties or characteristics of an entity with respect 
#   to safeguarding information; typically associated with internal data structures (e.g., records, buffers, files) within 
#   the information system which are used to enable the implementation of access control and flow control policies; 
#   reflect special dissemination, handling, or distribution instructions; or support other aspects of the information 
#   security policy. [NIST SP 800-53 Rev. 4]
        self._S = [
            "Security attribute #0",
            "Security attribute #1",
            "Security attribute #2",
            "Security attribute #3",
            "Security attribute #4"
        ]

    @property
    def n(self):
        return self._n

    @property
    def l(self):
        return self._l

    @property
    def S(self):
        return self._S


#  For testing simplicty I assume that A(i,0) = 1, A(i,j)=0 if j!=0 for any i
#  So no matrix is stored, I just generate a value as required 
#  Also I do not check that i is within valid range 0..l-1
    def A(self, i, j):
        if j==0:
            return 1
        return 0

# p - the function that associates rows of A with the (security?) attributes
# i - row of A, we return associated security attribute which is always "full access" 
    def p(self,i):
        return self._S[i] 

# A helper for lsabe.encrypt
# Choose a random s∈Zp and a random vector v∈Znp with s as its first entry.
    def randVector(self):
        v=[]
        for i in range(self._n):
            v.append(random.randrange(sys.maxsize)) 
        return v

# A helper for lsabe.encrypt
# For each i∈[l], we let λ(i) denote A(i)·v, where A(i) is row i of A 
# (and v - is a vector, generated by randVector)
    def lmbda(self, i, v):
        lm = 0
        for j in range (len(v)):
            lm += self.A(i,j)*v[j]
        return lm

# A helper for lsabe.transform
#  w - a set of constants {w(i)∈Zp} i∈N with Σ[w(i)*A(i)] = (1,0,...,0).
    def w(self, i):
        if i == 0:
            return 1
        return 0

